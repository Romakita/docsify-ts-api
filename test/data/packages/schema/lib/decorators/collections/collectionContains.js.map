{"version":3,"file":"collectionContains.js","sourceRoot":"","sources":["../../../src/decorators/collections/collectionContains.ts"],"names":[],"mappings":";;AAAA,iDAA4C;AAE5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCG;AACH,SAAgB,kBAAkB,CAAC,IAAS;IAC1C,OAAO,2BAAY,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,CAAC;AACvC,CAAC;AAFD,gDAEC","sourcesContent":["import {CollectionOf} from \"./collectionOf\";\n\n/**\n * Set the type of the item collection. The possible value is String, Boolean, Number, Date, Object, Class, etc...\n *\n * The array instance will be valid against \"contains\" if at least one of its elements is valid against the given schema.\n *\n * ```typescript\n * class Model {\n *    @CollectionContains(String).MinLength(0).MaxLength(0)\n *    property: string[];\n * }\n * ```\n * ::: warning\n * You musn't use the `type Type = string | number` as parameters Type.\n *\n * This example doesn't work:\n *\n * ```typescript\n * type Type = \"string\" | \"number\"\n * class Model {\n *    @PropertyType(Type)\n *    property: Type[];\n * }\n * ```\n * :::\n *\n * @param {Type<any>} type\n * @decorator\n * @ajv\n * @jsonMapper\n * @swagger\n * @schema\n * @propertyDecorator\n * @paramDecorator\n * @model\n */\nexport function CollectionContains(type: any) {\n  return CollectionOf(type).Contains();\n}\n"]}